<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Avatares en tiempo real</title>
<style>
  body {
    background: #111;
    color: #0f0;
    font-family: monospace;
    padding: 20px;
  }
  h2 { margin-bottom: 10px; }
  #status { font-weight: bold; }
  #avatars {
    display: flex;
    flex-wrap: wrap;
    margin-top: 20px;
  }
  .user-avatar {
    margin: 10px;
    text-align: center;
  }
  .user-avatar img {
    width: 100px;
    height: 100px;
    border: 2px solid #0f0;
    border-radius: 10px;
  }
  .buttons {
    margin-top: 10px;
  }
  .buttons button {
    margin: 5px;
    padding: 8px;
  }
</style>
</head>
<body>

<h2>ðŸŽ¤ Avatares en tiempo real</h2>
<p id="status">Conectando...</p>

<div class="buttons">
  <button id="btnIdle">Elegir imagen Idle</button>
  <input type="file" id="fileIdle" accept="image/*" style="display:none">

  <button id="btnTalk">Elegir imagen Talk</button>
  <input type="file" id="fileTalk" accept="image/*" style="display:none">

  <button id="btnAngry">Elegir imagen Angry</button>
  <input type="file" id="fileAngry" accept="image/*" style="display:none">
</div>

<div id="avatars"></div>

<script>
const USERNAME = prompt("Tu nombre (ej: juan):");

// ConexiÃ³n WebSocket
const socket = new WebSocket("wss://avatares-overlay.onrender.com");

const statusEl = document.getElementById("status");
const avatarsDiv = document.getElementById("avatars");

// Imagenes cargadas por el usuario
const avatarImages = {
  idle: null,
  talk: null,
  angry: null
};

// Divs de usuarios
const users = {};

// FunciÃ³n para manejar subida de archivos
function handleFile(file, state) {
  const reader = new FileReader();
  reader.onload = (e) => {
    avatarImages[state] = e.target.result;

    // Enviar la imagen al servidor en Base64
    socket.send(JSON.stringify({
      type: "avatar",
      user: USERNAME,
      state: state,
      image: e.target.result
    }));
  };
  reader.readAsDataURL(file);
}

// Botones
document.getElementById("btnIdle").onclick = () => document.getElementById("fileIdle").click();
document.getElementById("btnTalk").onclick = () => document.getElementById("fileTalk").click();
document.getElementById("btnAngry").onclick = () => document.getElementById("fileAngry").click();

document.getElementById("fileIdle").addEventListener("change", (e) => {
  if(e.target.files[0]) handleFile(e.target.files[0], "idle");
});
document.getElementById("fileTalk").addEventListener("change", (e) => {
  if(e.target.files[0]) handleFile(e.target.files[0], "talk");
});
document.getElementById("fileAngry").addEventListener("change", (e) => {
  if(e.target.files[0]) handleFile(e.target.files[0], "angry");
});

// WebSocket
socket.onopen = () => {
  statusEl.textContent = "ðŸŸ¢ Conectado al servidor";
  socket.send(JSON.stringify({ type: "join", user: USERNAME }));
};

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);

  let userDiv = users[data.user];
  if (!userDiv) {
    userDiv = document.createElement("div");
    userDiv.className = "user-avatar";
    userDiv.innerHTML = `<p>${data.user}</p><img src="" alt="avatar">`;
    avatarsDiv.appendChild(userDiv);
    users[data.user] = userDiv;
  }

  const img = userDiv.querySelector("img");

  // Si es un mensaje de avatar, actualiza la imagen correspondiente
  if (data.type === "avatar") {
    if (data.user === USERNAME) avatarImages[data.state] = data.image;
    if (img) img.src = data.image;
    return;
  }

  // Si es un mensaje de estado, cambia la imagen segÃºn el estado
  if (data.type === "state") {
    if (avatarImages[data.state]) {
      img.src = avatarImages[data.state];
    }
  }
};

socket.onclose = () => statusEl.textContent = "âŒ ConexiÃ³n cerrada";
socket.onerror = (err) => statusEl.textContent = "âš ï¸ Error WebSocket";

// MicrÃ³fono
let audioContext, analyser, dataArray;

navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
  audioContext = new AudioContext();
  const source = audioContext.createMediaStreamSource(stream);
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 256;
  source.connect(analyser);
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  setInterval(() => {
    analyser.getByteFrequencyData(dataArray);

    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];

    const volume = sum / dataArray.length / 255;

    let state = "idle";
    if (volume > 0.05) state = "talk";
    if (volume > 0.20) state = "angry";

    socket.send(JSON.stringify({
      type: "state",
      user: USERNAME,
      state: state,
      volume: volume
    }));

  }, 100);
});
</script>

</body>
</html>